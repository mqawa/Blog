<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>重载流操作符时遇到的问题（输出自定义数据类型到文件）</title>
      <link href="/21120601.html"/>
      <url>/21120601.html</url>
      
        <content type="html"><![CDATA[<hr><h3 id="如下代码，将Test类通过重载流操作符输出到文件，编译时会报错（二义性）"><a href="#如下代码，将Test类通过重载流操作符输出到文件，编译时会报错（二义性）" class="headerlink" title="如下代码，将Test类通过重载流操作符输出到文件，编译时会报错（二义性）"></a>如下代码，将Test类通过重载流操作符输出到文件，编译时会报错（二义性）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Test</span>(<span class="keyword">int</span> num) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;num = num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ofstream&amp; <span class="keyword">operator</span>&lt;&lt;(ofstream&amp; ofs, <span class="keyword">const</span> Test&amp; test) &#123;</span><br><span class="line">ofs &lt;&lt; test.num;</span><br><span class="line"><span class="keyword">return</span> ofs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">ofstream <span class="title">ofs</span><span class="params">(<span class="string">&quot;test.txt&quot;</span>, ios::out | ios::trunc)</span></span>;</span><br><span class="line">ofs &lt;&lt; <span class="built_in">Test</span>(<span class="number">10</span>) &lt;&lt; endl;</span><br><span class="line">ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">write</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="../../../images/cpp/overload_stream/error.png" alt="error"></p><hr><h3 id="错误原因"><a href="#错误原因" class="headerlink" title="错误原因"></a>错误原因</h3><ul><li><p><strong>std内置函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp;, <span class="keyword">const</span> <span class="keyword">int</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>自定义函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ofstream&amp; <span class="keyword">operator</span>&lt;&lt;(ofstream&amp; ofs, <span class="keyword">const</span> Test&amp; test);</span><br></pre></td></tr></table></figure></li><li><p><strong>当运行到</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ofs &lt;&lt; test.num;</span><br></pre></td></tr></table></figure></li><li><p><strong>&lt;&lt; 运算符的两个参数类型分别为（ofstream，int）</strong></p></li><li><p><strong>对于内置函数，第一个参数为父类引用指向子类对象（ostream -&gt; ofstream），第二个参数完全匹配。</strong></p></li><li><p><strong>对于自定义函数，第一个参数完全匹配，第二个参数因为Test类的构造函数可以隐式调用。Test test = 1; 是合法的</strong></p></li><li><p><strong>编译器不知道调用哪个函数来处理这个语句</strong></p></li></ul><hr><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><ul><li><p><strong>将构造函数前加explicit关键字，使构造函数不可进行隐式转换</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Test</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;num = num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>将 &lt;&lt; 的参数改为 ostream，重载ostream即可</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; ofs, <span class="keyword">const</span> Test&amp; test) &#123;</span><br><span class="line">ofs &lt;&lt; test.num;</span><br><span class="line"><span class="keyword">return</span> ofs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试</title>
      <link href="/21120103.html"/>
      <url>/21120103.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 玩得开心 </category>
          
          <category> game </category>
          
      </categories>
      
      
        <tags>
            
            <tag> play </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Test</title>
      <link href="/21120102.html"/>
      <url>/21120102.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前置自增（减）和后置自增（减）的区别以 及效率</title>
      <link href="/21120101.html"/>
      <url>/21120101.html</url>
      
        <content type="html"><![CDATA[<hr><h3 id="两者的区别"><a href="#两者的区别" class="headerlink" title="两者的区别"></a><strong>两者的区别</strong></h3><ul><li><strong>《C专家编程》中说道：“++x表示取x的地址，增加它的内容，然后把值放到寄存 器中，x++则表示取x的地址，把他的值装入寄存器中，然后增加内存中的x的 值”。</strong></li><li><strong>前置自增（减）返回的是对象的引用，后置自增（减）返回的是对象的拷贝，这 就意味着对前置自增（减）的操作会操作对象本身，而后置自增（减）不会。</strong></li><li><strong>在现代 IDE 中，会优化内置数据类型，统一为前置自增（减），来优化性能，但 是对于自定义数据类型的重载，前置自增（减）效率优于后置自增（减）。</strong></li></ul><hr><h3 id="为什么前置自增（减）优于后置自增（减）"><a href="#为什么前置自增（减）优于后置自增（减）" class="headerlink" title="为什么前置自增（减）优于后置自增（减）"></a><strong>为什么前置自增（减）优于后置自增（减）</strong></h3><ul><li><p><strong>对于内置数据类型，我们查看反汇编</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    ++i;</span><br><span class="line">    i++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><img src="../../../images/cpp/inc/int.png" alt="内置"></p></li><li><p><strong>我们发现，运算流程相同，说明编译器对后置自增（减）运算进行了优化</strong></p></li></ul></li><li><p><strong>对于自定义数据类型，我们重载自增（减）运算符后查看反汇编</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Test</span>() :<span class="built_in">num</span>(<span class="number">0</span>) &#123;&#125;;</span><br><span class="line">Test <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;<span class="comment">//后置自增</span></span><br><span class="line"><span class="keyword">this</span>-&gt;num++;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">Test&amp; <span class="keyword">operator</span>++() &#123;<span class="comment">//前置自增</span></span><br><span class="line"><span class="keyword">this</span>-&gt;num++;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Test t;</span><br><span class="line">++t;</span><br><span class="line">t++;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><img src="../../../images/cpp/inc/Test.png" alt="自定义"></li></ul></li><li><p><strong>或者可以通关禁用拷贝构造函数的方式进行验证</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Test</span>() :<span class="built_in">num</span>(<span class="number">0</span>) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">Test <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;num++;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Test&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;num++;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">Test</span>(<span class="keyword">const</span> Test&amp; test);<span class="comment">//禁用拷贝构造函数</span></span><br><span class="line">Test&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Test&amp; test);<span class="comment">//禁用赋值运算符</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Test t;</span><br><span class="line">++t;</span><br><span class="line">t++;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><img src="../../../images/cpp/inc/error.png" alt="error"></p></li><li><p><strong>会发现后置自增（减）链接错误，说明后置自增（减）调用了拷贝构造函数</strong></p></li></ul></li><li><p><strong>总结：不考虑返回值的话，前置自增（减）在编译器不优化的情况下，效率会优 于后置自增（减），因为后置自增（减）会对表达式进行一次拷贝，如果表达式 为自定义数据类型或者为迭代器等，拷贝的代价会非常大，前置和后置的功能一 样，优先使用前置自增（减）。</strong></p></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Visual Assist X 安装和破解</title>
      <link href="/share01001.html"/>
      <url>/share01001.html</url>
      
        <content type="html"><![CDATA[<hr><h3 id="官网链接"><a href="#官网链接" class="headerlink" title="官网链接"></a>官网链接</h3><p><strong>Visual Assist X 官网：</strong><a href="https://www.wholetomato.com/">https://www.wholetomato.com/</a> </p><p><strong>Everything 官网：</strong><a href="https://www.voidtools.com/zh-cn/">https://www.voidtools.com/zh-cn/</a></p><hr><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><strong>如果已安装 Visual Assist X 请先卸载</strong></p><p><strong>扩展-&gt;管理扩展-&gt;已安装-&gt;Visual Assist X-&gt;卸载-&gt;关闭Visual Studio-&gt;等待卸载完成</strong></p><p><strong>下载 Visual Assist X 破解文件 + Everything ：</strong><a href="http://cloud.mqawa.com/s/jdTg">Cloudreve</a>，<a href="https://pan.baidu.com/s/1aOO8UDlJTCwScXvoUtINLw">百度网盘</a> <strong>提取码：t7mm</strong></p><p><strong>下载解压，安装Everything 和 Visual Assist X</strong></p><p><img src="../../../images/share/software/devtools/visual_assist_x/1.png" alt="everything"><img src="../../../images/share/software/devtools/visual_assist_x/2.png" alt="visual assist"></p><hr><h3 id="破解"><a href="#破解" class="headerlink" title="破解"></a>破解</h3><p><strong>打开 Everything，搜索 VA_X.dll，如果安装多个版本的 Visual Studio，会检索到多个 VA_X.dll，需要全部替换</strong></p><p><strong>我的路径为 ： C:\Users\CtrlZ\AppData\Local\Microsoft\VisualStudio\16.0_45dbff82\Extensions\5tmzqshx.03l</strong></p><p><strong>无法使用 Everything 可以参考路径寻找</strong></p><p><img src="../../../images/share/software/devtools/visual_assist_x/3.png" alt="搜索结果"></p><p><strong>把解压好的VA_X.dll，替换到打开的路径，破解完成</strong></p><p>本站资源仅供技术交流，请勿用于商业及非法用途，如产生法律纠纷与本站无关</p><hr>]]></content>
      
      
      <categories>
          
          <category> 资源分享 </category>
          
          <category> 软件资源 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 资源分享 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
