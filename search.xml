<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>一些乱七八糟的问题</title>
      <link href="/21120602.html"/>
      <url>/21120602.html</url>
      
        <content type="html"><![CDATA[<hr><h3 id="重载-to-string"><a href="#重载-to-string" class="headerlink" title="重载 to_string"></a>重载 to_string</h3><details ><summary> 重载to_string使得map，vector等容器可以转化为string字符串 </summary>              <div class='content'>              <p><strong>使用 ostringstream 进行链式字符串拼接</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">to_string</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span></span><br><span class="line"><span class="function">string <span class="title">to_string</span><span class="params">(<span class="keyword">const</span> pair&lt;K, V&gt;&amp; p)</span> </span>&#123;</span><br><span class="line">ostringstream o;</span><br><span class="line">o &lt;&lt; <span class="built_in">to_string</span>(p.first) &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; <span class="built_in">to_string</span>(p.second);</span><br><span class="line"><span class="keyword">return</span> o.<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">string <span class="title">to_string</span><span class="params">(<span class="keyword">const</span> T&amp; begin, <span class="keyword">const</span> T&amp; end)</span> </span>&#123;</span><br><span class="line">ostringstream o;</span><br><span class="line"><span class="keyword">for</span> (T it = begin; it != end; ++it) &#123;</span><br><span class="line"><span class="keyword">if</span> (it != begin)</span><br><span class="line">o &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">o &lt;&lt; <span class="built_in">to_string</span>(*it);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> o.<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span></span><br><span class="line"><span class="function">string <span class="title">to_string</span><span class="params">(<span class="keyword">const</span> map&lt;K, V&gt;&amp; m)</span> </span>&#123;</span><br><span class="line">ostringstream o;</span><br><span class="line">o &lt;&lt; <span class="string">&quot;&#123; &quot;</span> &lt;&lt; <span class="built_in">to_string</span>(m.<span class="built_in">begin</span>(), m.<span class="built_in">end</span>()) &lt;&lt; <span class="string">&quot; &#125;&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> o.<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">string <span class="title">to_string</span><span class="params">(<span class="keyword">const</span> vector&lt;T&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">ostringstream o;</span><br><span class="line">o &lt;&lt; <span class="string">&quot;[ &quot;</span> &lt;&lt; <span class="built_in">to_string</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>()) &lt;&lt; <span class="string">&quot; ]&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> o.<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">map&lt;string, string&gt; m;</span><br><span class="line">m.<span class="built_in">insert</span>(pair&lt;string, string&gt;(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;test&quot;</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(pair&lt;string, string&gt;(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;22&quot;</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(pair&lt;string, string&gt;(<span class="string">&quot;sex&quot;</span>, <span class="string">&quot;男&quot;</span>));</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">cout &lt;&lt; <span class="built_in">to_string</span>(m) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">to_string</span>(v) &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><hr><h3 id="cout-输出true-false"><a href="#cout-输出true-false" class="headerlink" title="cout 输出true, false"></a>cout 输出true, false</h3><details ><summary> 使cout输出true，false而不是1，0 </summary>              <div class='content'>              <p><strong>在默认情况下，cout会将true, false转换为1, 0输出，而不是输出true, false</strong></p><p><strong>解决： 使用boolalpha，头文件iostream</strong></p><p><strong>当使用boolalpha后，以后的bool类型结果都将以true或false形式输出，除非使用 noboolalpha取消 boolalpha流的格式标志</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;boolalpha&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; boolalpha;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;true : &quot;</span> &lt;&lt; <span class="literal">true</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;false : &quot;</span> &lt;&lt; <span class="literal">false</span> &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;noboolalpha&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; noboolalpha;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;true : &quot;</span> &lt;&lt; <span class="literal">true</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;false : &quot;</span> &lt;&lt; <span class="literal">false</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><hr><h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><details ><summary> 函数指针的使用 </summary>              <div class='content'>              <p><strong>函数指针的定义：函数返回值类型 (* 指针变量名) (函数参数列表);</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;&#125;</span><br><span class="line"><span class="built_in"><span class="keyword">void</span></span> (*p)(<span class="keyword">int</span>);<span class="comment">//定义了一个返回值为void，参数列表为int，且只有一个参数的函数指针</span></span><br><span class="line">p = func;<span class="comment">//指向函数</span></span><br></pre></td></tr></table></figure><p><strong>函数指针的使用</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in"><span class="keyword">void</span></span>(*p)(<span class="keyword">int</span>) = func;</span><br><span class="line"><span class="built_in">p</span>(<span class="number">1</span>);<span class="comment">//理解：函数名就是指针，所以使用函数指针与使用函数一样</span></span><br><span class="line">(*p)(<span class="number">1</span>);<span class="comment">//理解：指针p指向函数，所以要解析指针</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><hr><h3 id="构造和析构函数是否可以为虚函数？"><a href="#构造和析构函数是否可以为虚函数？" class="headerlink" title="构造和析构函数是否可以为虚函数？"></a>构造和析构函数是否可以为虚函数？</h3><details ><summary> 构造和析构函数是否可以为虚函数？ </summary>              <div class='content'>              <p><strong>构造函数不可以为虚函数，析构函数可以</strong></p><details ><summary> 为什么构造函数不可以为虚函数 </summary>              <div class='content'>              <p><strong>虚函数的调用需要虚函数表指针，而该指针存放在对象的内容空间中；若构造函 数声明为虚函数，那么由于对象还未创建，还没有内存空间，更没有虚函数表地 址用来调用虚函数——构造函数了。</strong></p>              </div>            </details><details ><summary> 为什么析构函数可以为虚函数 </summary>              <div class='content'>              <p><strong>当要使用基类指针或引用调用子类时，最好将基类 的析构函数声明为虚函数，否则可能存在内存泄露的问题。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;make Base&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Base</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;del Base&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Son</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;make Son&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Son</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;del Son&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Base* p = <span class="keyword">new</span> <span class="built_in">Son</span>();</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="../../images/cpp/emmm/%E6%9E%84%E9%80%A001.png" alt="构造01"></p><p><strong>根据输出可见，Son的析构函数未被调用，存在内存泄露问题，将Base类的析构函数声明为虚函数即可解决</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;make Base&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;del Base&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Son</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;make Son&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Son</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;del Son&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Base* p = <span class="keyword">new</span> <span class="built_in">Son</span>();</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="../../images/cpp/emmm/%E6%9E%84%E9%80%A002.png" alt="构造01"></p>              </div>            </details>              </div>            </details><hr><h3 id="成员变量初始化顺序"><a href="#成员变量初始化顺序" class="headerlink" title="成员变量初始化顺序"></a>成员变量初始化顺序</h3><details ><summary> 成员变量初始化顺序 </summary>              <div class='content'>              <p><strong>成员变量的声明顺序，决定了成员变量的初始化顺序。假设 Date 类中的构造函数为：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Date</span>() : <span class="built_in">y</span>(<span class="number">2016</span>), <span class="built_in">m</span>(<span class="number">2</span>), <span class="built_in">d</span>(<span class="number">4</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>此时，成员变量，在类中的声明顺序 = 构造函数初始化列表顺序，故 y, m, d 都能被顺利的 初始化为对应的值。</strong></p><p><strong>而当成员变量，在类中的声明顺序 ≠ 构造函数初始化列表顺序 时，如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Date</span>() : <span class="built_in">y</span>(<span class="number">2016</span>), <span class="built_in">d</span>(<span class="number">4</span>), <span class="built_in">m</span>(d<span class="number">-2</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>根据成员变量的声明顺序，y 首先被初始化为 2016，然后再初始化 m，但由于 d 并未被初始 化，所以 m 的值是随机的，最后初始化 d 为 4</strong></p><p><strong>因为，<span class='p red'>类的成员变量在初始化时，其初始化的顺序只与声明顺序有关，而与初始化顺序无关。</span></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Date</span>() :<span class="built_in">y</span>(<span class="number">2021</span>), <span class="built_in">d</span>(<span class="number">4</span>), <span class="built_in">m</span>(d - <span class="number">2</span>) &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;y : &quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;m : &quot;</span> &lt;&lt; m &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;d : &quot;</span> &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> y, m, d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Date date;</span><br><span class="line">date.<span class="built_in">printDate</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="../../images/cpp/emmm/%E5%88%9D%E5%A7%8B%E5%8C%96.png" alt="初始化"></p>              </div>            </details><hr><h3 id="C-的函数重载"><a href="#C-的函数重载" class="headerlink" title="C++的函数重载"></a>C++的函数重载</h3><details ><summary> C++的函数重载 </summary>              <div class='content'>              <ul><li><p><strong>为什么要进行函数重载</strong></p><ul><li><strong>为了简化编程</strong></li><li><strong>提高编程效率</strong></li><li><strong>增加代码可读性</strong></li></ul></li><li><p><strong>函数重载的规则</strong></p><ul><li><strong>函数名相同</strong></li><li><strong>函数的参数列表不同（参数个数，类型，顺序不同等）</strong></li><li><strong>函数的返回值可以不同</strong></li><li><strong>仅仅返回类型不同不足以成为函数的重载</strong></li></ul></li><li><p><strong>命名倾轧</strong></p><ul><li><strong>C++函数重载底层实现原理是C++利用name mangling(倾轧)技术，来改名函数 名，区分参数不同的同名函数。</strong></li><li><strong>编译器通过函数名和其参数类型识别重载函数。为了保证类型安全的连接（typesafe linkage），编译器用参数个数和参数类型对每一个函数标识符进行专门编 码，这个过程有时称为“名字改编”（name mangling）或“名字修饰”（name decoration）。类型安全的连接使得程序能够调用合适的重载函数并保证了参数 传递的一致性。编译器能够检测到并报告连接错误。</strong></li></ul></li><li><p><strong>查看符号表</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">func</span><span class="params">(<span class="keyword">double</span> a)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>使用 g++ -c 只编译不链接，只生成目标文件</strong></p></li><li><p><strong>使用 nm 查看目标文件（.o）</strong></p><p><img src="../../images/cpp/emmm/%E9%87%8D%E8%BD%BD.png" alt="重载"></p></li></ul></li></ul>              </div>            </details><hr>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重载流操作符时遇到的问题（输出自定义数据类型到文件）</title>
      <link href="/21120601.html"/>
      <url>/21120601.html</url>
      
        <content type="html"><![CDATA[<hr><h3 id="如下代码，将Test类通过重载流操作符输出到文件，编译时会报错（二义性）"><a href="#如下代码，将Test类通过重载流操作符输出到文件，编译时会报错（二义性）" class="headerlink" title="如下代码，将Test类通过重载流操作符输出到文件，编译时会报错（二义性）"></a>如下代码，将Test类通过重载流操作符输出到文件，编译时会报错（二义性）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Test</span>(<span class="keyword">int</span> num) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;num = num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ofstream&amp; <span class="keyword">operator</span>&lt;&lt;(ofstream&amp; ofs, <span class="keyword">const</span> Test&amp; test) &#123;</span><br><span class="line">ofs &lt;&lt; test.num;</span><br><span class="line"><span class="keyword">return</span> ofs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">ofstream <span class="title">ofs</span><span class="params">(<span class="string">&quot;test.txt&quot;</span>, ios::out | ios::trunc)</span></span>;</span><br><span class="line">ofs &lt;&lt; <span class="built_in">Test</span>(<span class="number">10</span>) &lt;&lt; endl;</span><br><span class="line">ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">write</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="../../../images/cpp/overload_stream/error.png" alt="error"></p><hr><h3 id="错误原因"><a href="#错误原因" class="headerlink" title="错误原因"></a>错误原因</h3><ul><li><p><strong>std内置函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp;, <span class="keyword">const</span> <span class="keyword">int</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>自定义函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ofstream&amp; <span class="keyword">operator</span>&lt;&lt;(ofstream&amp; ofs, <span class="keyword">const</span> Test&amp; test);</span><br></pre></td></tr></table></figure></li><li><p><strong>当运行到</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ofs &lt;&lt; test.num;</span><br></pre></td></tr></table></figure></li><li><p><strong>&lt;&lt; 运算符的两个参数类型分别为（ofstream，int）</strong></p></li><li><p><strong>对于内置函数，第一个参数为父类引用指向子类对象（ostream -&gt; ofstream），第二个参数完全匹配。</strong></p></li><li><p><strong>对于自定义函数，第一个参数完全匹配，第二个参数因为Test类的构造函数可以隐式调用。Test test = 1; 是合法的</strong></p></li><li><p><strong>编译器不知道调用哪个函数来处理这个语句</strong></p></li></ul><hr><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><ul><li><p><strong>将构造函数前加explicit关键字，使构造函数不可进行隐式转换</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Test</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;num = num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>将 &lt;&lt; 的参数改为 ostream，重载ostream即可</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; ofs, <span class="keyword">const</span> Test&amp; test) &#123;</span><br><span class="line">ofs &lt;&lt; test.num;</span><br><span class="line"><span class="keyword">return</span> ofs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试</title>
      <link href="/21120103.html"/>
      <url>/21120103.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 玩得开心 </category>
          
          <category> game </category>
          
      </categories>
      
      
        <tags>
            
            <tag> play </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Test</title>
      <link href="/21120102.html"/>
      <url>/21120102.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前置自增（减）和后置自增（减）的区别以 及效率</title>
      <link href="/21120101.html"/>
      <url>/21120101.html</url>
      
        <content type="html"><![CDATA[<hr><h3 id="两者的区别"><a href="#两者的区别" class="headerlink" title="两者的区别"></a><strong>两者的区别</strong></h3><ul><li><strong>《C专家编程》中说道：“++x表示取x的地址，增加它的内容，然后把值放到寄存 器中，x++则表示取x的地址，把他的值装入寄存器中，然后增加内存中的x的 值”。</strong></li><li><strong>前置自增（减）返回的是对象的引用，后置自增（减）返回的是对象的拷贝，这 就意味着对前置自增（减）的操作会操作对象本身，而后置自增（减）不会。</strong></li><li><strong>在现代 IDE 中，会优化内置数据类型，统一为前置自增（减），来优化性能，但 是对于自定义数据类型的重载，前置自增（减）效率优于后置自增（减）。</strong></li></ul><hr><h3 id="为什么前置自增（减）优于后置自增（减）"><a href="#为什么前置自增（减）优于后置自增（减）" class="headerlink" title="为什么前置自增（减）优于后置自增（减）"></a><strong>为什么前置自增（减）优于后置自增（减）</strong></h3><ul><li><p><strong>对于内置数据类型，我们查看反汇编</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    ++i;</span><br><span class="line">    i++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><img src="../../../images/cpp/inc/int.png" alt="内置"></p></li><li><p><strong>我们发现，运算流程相同，说明编译器对后置自增（减）运算进行了优化</strong></p></li></ul></li><li><p><strong>对于自定义数据类型，我们重载自增（减）运算符后查看反汇编</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Test</span>() :<span class="built_in">num</span>(<span class="number">0</span>) &#123;&#125;;</span><br><span class="line">Test <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;<span class="comment">//后置自增</span></span><br><span class="line"><span class="keyword">this</span>-&gt;num++;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">Test&amp; <span class="keyword">operator</span>++() &#123;<span class="comment">//前置自增</span></span><br><span class="line"><span class="keyword">this</span>-&gt;num++;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Test t;</span><br><span class="line">++t;</span><br><span class="line">t++;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><img src="../../../images/cpp/inc/Test.png" alt="自定义"></li></ul></li><li><p><strong>或者可以通关禁用拷贝构造函数的方式进行验证</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Test</span>() :<span class="built_in">num</span>(<span class="number">0</span>) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">Test <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;num++;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Test&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;num++;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">Test</span>(<span class="keyword">const</span> Test&amp; test);<span class="comment">//禁用拷贝构造函数</span></span><br><span class="line">Test&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Test&amp; test);<span class="comment">//禁用赋值运算符</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Test t;</span><br><span class="line">++t;</span><br><span class="line">t++;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><img src="../../../images/cpp/inc/error.png" alt="error"></p></li><li><p><strong>会发现后置自增（减）链接错误，说明后置自增（减）调用了拷贝构造函数</strong></p></li></ul></li><li><p><strong>总结：不考虑返回值的话，前置自增（减）在编译器不优化的情况下，效率会优 于后置自增（减），因为后置自增（减）会对表达式进行一次拷贝，如果表达式 为自定义数据类型或者为迭代器等，拷贝的代价会非常大，前置和后置的功能一 样，优先使用前置自增（减）。</strong></p></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Visual Assist X 安装和破解</title>
      <link href="/share01001.html"/>
      <url>/share01001.html</url>
      
        <content type="html"><![CDATA[<hr><h3 id="官网链接"><a href="#官网链接" class="headerlink" title="官网链接"></a>官网链接</h3><p><strong>Visual Assist X 官网：</strong><a href="https://www.wholetomato.com/">https://www.wholetomato.com/</a> </p><p><strong>Everything 官网：</strong><a href="https://www.voidtools.com/zh-cn/">https://www.voidtools.com/zh-cn/</a></p><hr><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><strong>如果已安装 Visual Assist X 请先卸载</strong></p><p><strong>扩展-&gt;管理扩展-&gt;已安装-&gt;Visual Assist X-&gt;卸载-&gt;关闭Visual Studio-&gt;等待卸载完成</strong></p><p><strong>下载 Visual Assist X 破解文件 + Everything ：</strong><a href="http://cloud.mqawa.com/s/jdTg">Cloudreve</a>，<a href="https://pan.baidu.com/s/1aOO8UDlJTCwScXvoUtINLw">百度网盘</a> <strong>提取码：t7mm</strong></p><p><strong>下载解压，安装Everything 和 Visual Assist X</strong></p><p><img src="../../../images/share/software/devtools/visual_assist_x/1.png" alt="everything"><img src="../../../images/share/software/devtools/visual_assist_x/2.png" alt="visual assist"></p><hr><h3 id="破解"><a href="#破解" class="headerlink" title="破解"></a>破解</h3><p><strong>打开 Everything，搜索 VA_X.dll，如果安装多个版本的 Visual Studio，会检索到多个 VA_X.dll，需要全部替换</strong></p><p><strong>我的路径为 ： C:\Users\CtrlZ\AppData\Local\Microsoft\VisualStudio\16.0_45dbff82\Extensions\5tmzqshx.03l</strong></p><p><strong>无法使用 Everything 可以参考路径寻找</strong></p><p><img src="../../../images/share/software/devtools/visual_assist_x/3.png" alt="搜索结果"></p><p><strong>把解压好的VA_X.dll，替换到打开的路径，破解完成</strong></p><p>本站资源仅供技术交流，请勿用于商业及非法用途，如产生法律纠纷与本站无关</p><hr>]]></content>
      
      
      <categories>
          
          <category> 资源分享 </category>
          
          <category> 软件资源 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 资源分享 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
